// Code generated by 'go generate'; DO NOT EDIT.

package main

import (
	"fmt"
	"syscall"
	"path/filepath"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

// Do the interface allocations only once for common
// Errno values.
const (
	errnoERROR_IO_PENDING = 997
)

var (
	errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)
	errERROR_EINVAL     error = syscall.EINVAL
)

// errnoErr returns common boxed Errno values, to prevent
// allocations at runtime.
func errnoErr(e syscall.Errno) error {
	switch e {
	case 0:
		return errERROR_EINVAL
	case errnoERROR_IO_PENDING:
		return errERROR_IO_PENDING
	}
	// TODO: add more here, after collecting data on the common
	// error values see on Windows. (perhaps when running
	// all.bat?)
	return e
}

var (
	modcore = windows.NewLazyDLL(filepath.Join(".", "lib",  "core.dll"))

	procInitialize    = modcore.NewProc("initialize")
	procOpenjtalkDict = modcore.NewProc("voicevox_load_openjtalk_dict")
	procMetas         = modcore.NewProc("metas")
)

func Initialize(useGpu bool, cpuNumThreads int) (r bool, err error) {
	var _p1, _p2 uint32
	if useGpu {
		_p1 = 1
	}
	_p2 = uint32(cpuNumThreads)
	fmt.Println(_p2)
	//r0, _, e1 := syscall.Syscall(procInitialize.Addr(), 2, uintptr(_p1), uintptr(_p2), 0)
	r0, _, e1 := procInitialize.Call(uintptr(_p1), uintptr(_p2))
	r = r0 != 0
	if r == false {
		err = errnoErr(e1)
	}
	return
}

func VoicevoxLoadOpenjtalkDict(openjtalkDict string) (r bool, err error) {
	var _p0 *byte
	_p0, err = syscall.BytesPtrFromString(filepath.Join(".", openjtalkDict))
	fmt.Println(_p0)
	if err != nil {
		return
	}
	return voicevoxLoadOpenjtalkDict(_p0)
}

func voicevoxLoadOpenjtalkDict(openjtalkDict *byte) (r bool, err error) {
	//r0, r1, e1 := syscall.Syscall(procOpenjtalkDict.Addr(), 1, uintptr(unsafe.Pointer(openjtalkDict)), 0, 0)
	r0, r1, e1 := procOpenjtalkDict.Call(uintptr(unsafe.Pointer(openjtalkDict)))
	fmt.Println(r0, r1)
	r = r0 != 0
	if r == false {
		err = errnoErr(e1)
	}
	return
}

func Metas() (metas string, err error) {
	//r0, _, e1 := syscall.Syscall(procMetas.Addr(), 0, 0, 0, 0)
	r0, _, e1 := procMetas.Call()
	metas = string(r0)
	if metas == "" {
		err = errnoErr(e1)
	}
	return
}
